from collections import deque

# Hex dump from DAT_00104280 (32 bytes = 8 columns Ã— 4 rows)
hex_bytes = bytes.fromhex(
    "1c7c5595ca43893c6a953e96ca359ebcaa9c2aaaaa2acaa3eac3a33c76353c16"
)

# Convert into 32-bit values (one per column)
columns = [int.from_bytes(hex_bytes[i:i+4], 'little') for i in range(0, len(hex_bytes), 4)]

# Create maze[row][col] = movement mask (4 bits: up, left, down, right)
maze = [[((columns[col] >> (row * 4)) & 0xF) for col in range(len(columns))] for row in range(8)]

# Movement directions and corresponding bits
directions = {
    0: (-1,  0),  # up
    1: ( 0, -1),  # left
    2: ( 1,  0),  # down
    3: ( 0,  1),  # right
}

# BFS to find 16-step path from (3,0) to (4,7)
start = (3, 0)
goal = (4, 7)
max_steps = 16
queue = deque()
queue.append((start, [], 0))

def in_bounds(r, c):
    return 0 <= r < 8 and 0 <= c < 8

solution_bits = None

while queue:
    (r, c), path, steps = queue.popleft()
    if steps == max_steps:
        if (r, c) == goal:
            solution_bits = path
            break
        continue

    for dir_bits, (dr, dc) in directions.items():
        nr, nc = r + dr, c + dc
        if not in_bounds(nr, nc):
            continue
        if (maze[r][c] >> dir_bits) & 1:
            queue.append(((nr, nc), path + [dir_bits], steps + 1))

# Encode 16 directions (2 bits each) into 32-bit integer
if solution_bits and len(solution_bits) == 16:
    value = 0
    for i, move in enumerate(solution_bits):
        value |= (move & 0b11) << (i * 2)
    print(f"[+] Found valid input: {value} (0x{value:08x})")
    print(f"[+] Movement sequence: {solution_bits}")
else:
    print("[-] No valid path found.")

