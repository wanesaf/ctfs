from collections import deque


hex_bytes = bytes.fromhex(
    "1c7c5595ca43893c6a953e96ca359ebcaa9c2aaaaa2acaa3eac3a33c76353c16"
)


columns = [int.from_bytes(hex_bytes[i:i+4], 'little') for i in range(0, len(hex_bytes), 4)]


maze = [[((columns[col] >> (row * 4)) & 0xF) for col in range(len(columns))] for row in range(8)]


directions = {
    0: (-1,  0),  # up
    1: ( 0, -1),  # left
    2: ( 1,  0),  # down
    3: ( 0,  1),  # right
}

# BFS to find 16-step path from (3,0) to (4,7)
start = (3, 0)
goal = (4, 7)
max_steps = 16
queue = deque()
queue.append((start, [], 0))

def in_bounds(r, c):
    return 0 <= r < 8 and 0 <= c < 8

solution_bits = None

while queue:
    (r, c), path, steps = queue.popleft()
    if steps == max_steps:
        if (r, c) == goal:
            solution_bits = path
            break
        continue

    for dir_bits, (dr, dc) in directions.items():
        nr, nc = r + dr, c + dc
        if not in_bounds(nr, nc):
            continue
        if (maze[r][c] >> dir_bits) & 1:
            queue.append(((nr, nc), path + [dir_bits], steps + 1))


if solution_bits and len(solution_bits) == 16:
    value = 0
    for i, move in enumerate(solution_bits):
        value |= (move & 0b11) << (i * 2)
    print(f"[+] Found valid input: {value} (0x{value:08x})")
    print(f"[+] Movement sequence: {solution_bits}")
else:
    print("[-] No valid path found.")

